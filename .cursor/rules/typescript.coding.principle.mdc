---
alwaysApply: true
---

# TypeScript Coding Principles

## Core Principles

### KISS Principle (Keep It Simple, Stupid)
- Write simple, straightforward code that is easy to understand
- Avoid unnecessary complexity and over-engineering
- Prefer clear, readable solutions over clever ones
- If a solution seems too complicated, simplify it

### DRY Principle (Don't Repeat Yourself)
- Avoid code duplication
- Extract common logic into reusable functions or utilities
- Use shared constants, types, and helpers
- Refactor repeated patterns into abstractions

### SRP Principle (Single Responsibility Principle)
- Each function, class, or module should have one clear responsibility
- `A function` MUST do `one thing(file)` and do it well
- If a function does multiple things, split it into smaller functions
- Keep functions focused and cohesive

### Open-Closed Principle
- Code should be open for extension but closed for modification
- Design functions and classes to be extensible without changing existing code
- Use interfaces, abstract classes, and dependency injection to enable extension
- Prefer composition over modification when adding new features

## File Organization

### One Function Per File
- Each function should be defined in its own file
- The file name should match the function name (e.g., `getMaxBlockTimestamp.ts` exports `getMaxBlockTimestamp`)
- This improves:
  - Code discoverability
  - Easier testing
  - Better code organization
  - Reduced merge conflicts

### Supabase Query Functions
- All pure Supabase query functions must be organized in the `supabase` folder
- Group functions by table: `supabase/[table_name]/`
- Example structure:
  ```
  supabase/
    in_process_tokens/
      selectTokens.ts
      upsertTokens.ts
    in_process_payments/
      selectPayments.ts
      upsertPayments.ts
  ```
- Keep query functions pure and focused on database operations
- Separate business logic from database queries

### Types
- All types should be defined in a `types` folder
- Example structure:
  ```
  types/
    moments.ts
  ```
- Keep type definitions organized and easily discoverable
- Export types from a central location when shared across modules

## Best Practices

### Function Design
- Keep functions small and focused
- Use descriptive names that clearly indicate purpose
- Prefer pure functions when possible (no side effects)
- Handle errors explicitly and gracefully

### Type Safety
- Use TypeScript types and interfaces consistently
- Avoid `any` types; use `unknown` when type is truly unknown
- Leverage TypeScript's type inference where appropriate
- Define types in the `types` folder (see File Organization section)

### Code Structure
- Group related functionality together
- Maintain clear separation of concerns
- Use consistent naming conventions
- Follow the existing project structure patterns

## API Fetching Patterns

### Use TanStack Query + Separate API Logic
**Pattern**: When implementing hooks that fetch data from API endpoints:
1. **ALWAYS use TanStack Query** (`useQuery` or `useInfiniteQuery`) instead of manual `useState`/`useEffect`
2. Separate the API fetching logic into a dedicated function in `lib/` directory

**Structure**:
- **API Function**: `lib/moment/getInProcessTimelineApi.ts` (or similar) - Contains pure fetch logic, error handling, and response parsing
- **Hook**: `hooks/useInProcessTimeline.ts` - Uses `useQuery` from TanStack Query to manage data fetching

**Benefits**:
- TanStack Query provides built-in caching, refetching, error handling, and loading states
- Follows SRP (Single Responsibility Principle) - API logic separate from React logic
- Reusable API functions can be used outside of hooks
- Easier to test API functions independently
- Automatic request deduplication and background refetching
- Better performance with built-in caching

**Example Pattern**:
```typescript
// lib/moment/getInProcessTimelineApi.ts
export const getInProcessTimelineApi = async (): Promise<TimelineMoment[]> => {
  const res = await fetch("/api/timeline/inprocess");
  // ... error handling and response parsing
  return data.moments || [];
};

// hooks/useInProcessTimeline.ts
import { useQuery } from "@tanstack/react-query";
import { getInProcessTimelineApi } from "@/lib/moment/getInProcessTimelineApi";

const useInProcessTimeline = () => {
  const query = useQuery({
    queryKey: ["in-process-timeline"],
    queryFn: getInProcessTimelineApi,
    staleTime: 60_000, // 1 minute
    refetchOnWindowFocus: false,
  });

  return {
    moments: query.data ?? [],
    isLoading: query.isLoading,
    error: query.error instanceof Error ? query.error : null,
  };
};
```

**Key Points**:
- **Always prefer TanStack Query** over manual state management for API data fetching
- Use descriptive `queryKey` arrays (e.g., `["in-process-timeline"]` or `["tokenInfo", address, tokenId]`)
- Configure `staleTime` and `refetchOnWindowFocus` based on data freshness requirements
- Return custom shape from hook if needed for backward compatibility


