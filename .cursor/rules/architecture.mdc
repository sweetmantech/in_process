---
alwaysApply: true
---

# TypeScript Coding Principles

## üìã IMPORTANT: ALWAYS CHECK AND UPDATE THIS FILE

**BEFORE STARTING ANY TASK:**
1. **READ THIS FILE FIRST** - These rules apply to ALL project development
2. **UPDATE THIS FILE** - When the user provides guidance, patterns, or corrections, immediately update this file to reflect them
3. **REFERENCE THIS FILE** - Use these principles for every code change, file creation, or refactoring
4. **MAINTAIN CONSISTENCY** - All code must follow the patterns and rules defined here

**WHEN USER PROVIDES GUIDANCE:**
- If they correct a pattern or approach ‚Üí Update the relevant section in this file
- If they introduce a new pattern ‚Üí Add it to the Code Patterns section
- If they clarify a rule ‚Üí Update the rule to be more explicit
- If they change file organization ‚Üí Update the File Organization section

**This file is the single source of truth for all coding standards in this project.**

---

## ‚ö†Ô∏è CRITICAL RULE: ONE FUNCTION PER FILE ‚ö†Ô∏è

**THIS IS THE MOST IMPORTANT RULE - CHECK THIS FIRST BEFORE CREATING OR MODIFYING ANY FILE**

- **EVERY function MUST be in its own separate file**
- **The file name MUST match the function name** (e.g., `getMaxBlockTimestamp.ts` exports `getMaxBlockTimestamp`)
- **NO exceptions** - helper functions, type guards, utility functions, ALL functions must be separate files
- **If a file has multiple functions, you MUST split them immediately**

**Examples:**
- ‚úÖ GOOD: `lib/fileSelect/loadPdfJs.ts` exports only `loadPdfJs`
- ‚úÖ GOOD: `lib/fileSelect/isPdfJsLib.ts` exports only `isPdfJsLib`
- ‚ùå BAD: `lib/fileSelect/loadPdfJs.ts` contains both `loadPdfJs` AND `isPdfJsLib`
- ‚ùå BAD: `lib/utils/helpers.ts` with multiple functions - split into separate files

**Before creating or editing any file, ask yourself:**
1. Does this file contain only ONE exported function?
2. If there are helper functions, are they in separate files?
3. If there are type guards, are they in separate files?

**If the answer to any question is NO, split the file immediately.**

---

## ‚ö†Ô∏è CRITICAL RULE: TYPES MUST BE IN TYPES FOLDER ‚ö†Ô∏è

**THIS IS THE SECOND MOST IMPORTANT RULE - CHECK THIS BEFORE CREATING OR MODIFYING ANY TYPE/INTERFACE**

- **ALL types, interfaces, and type definitions MUST be in the `types/` folder**
- **NO types defined in `lib/`, `components/`, `hooks/`, or any other folder**
- **If you see a type/interface defined outside `types/`, move it immediately**
- **Functions, hooks, and components import types from `types/`, never define them locally**

**Examples:**
- ‚úÖ GOOD: `types/collections.ts` exports `CollectionsResponse` interface
- ‚úÖ GOOD: `lib/collections/fetchCollections.ts` imports `CollectionsResponse` from `@/types/collections`
- ‚ùå BAD: `lib/collections/fetchCollections.ts` defines `CollectionsResponse` interface
- ‚ùå BAD: `components/CreateForm/Collections.tsx` defines `CollectionItem` type locally

**Before creating or editing any file, ask yourself:**
1. Does this file define any types, interfaces, or type aliases?
2. Are these types used in multiple places?
3. Should these types be shared?

**If the answer to ANY question is YES, move the types to the `types/` folder immediately.**

**When moving types:**
1. Create or update file in `types/` folder (e.g., `types/collections.ts`)
2. Export the type/interface from the types file
3. Update the original file to import the type instead of defining it
4. Update ALL files that use the type to import from `types/`

---

## ‚ö†Ô∏è CRITICAL RULE: COMPONENTS = HTML/JSX ONLY ‚ö†Ô∏è

**THIS IS THE THIRD MOST IMPORTANT RULE - CHECK THIS BEFORE CREATING OR MODIFYING ANY COMPONENT**

- **Components MUST contain ONLY HTML/JSX code** (< 120 lines)
- **NO business logic in components** - extract ALL logic to hooks or utility functions
- **NO calculations, conditionals, or data transformations** - move to hooks/functions
- **NO event handlers with logic** - extract handlers to hooks
- **NO derived state calculations** - move to hooks or utility functions

**What NOT to put in components:**
- ‚ùå `const hasSelectedFiles = Boolean(previewFile || imageFile || animationFile);` - move to hook
- ‚ùå `const handleReset = () => { /* logic */ }` - extract to hook
- ‚ùå `const formattedPrice = formatPrice(price)` - move calculation to hook
- ‚ùå `useEffect` hooks - extract to custom hooks
- ‚ùå Complex conditionals - move to utility functions or hooks

**What TO put in components:**
- ‚úÖ JSX/HTML markup only
- ‚úÖ Hook calls (useState, useQuery, custom hooks)
- ‚úÖ Props destructuring
- ‚úÖ Simple prop passing to child components
- ‚úÖ Conditional rendering using values from hooks

**Before creating or editing any component, ask yourself:**
1. Does this component contain ANY business logic or calculations?
2. Are there any event handlers with logic?
3. Are there any derived values calculated in the component?
4. Are there any useEffect hooks?

**If the answer to ANY question is YES, extract the logic to a hook or utility function immediately.**

---

## Core Principles

### KISS (Keep It Simple, Stupid)
- Write simple, straightforward code that is easy to understand
- Avoid unnecessary complexity and over-engineering
- Prefer clear, readable solutions over clever ones

### DRY (Don't Repeat Yourself)
- Avoid code duplication
- Extract common logic into reusable functions or utilities
- Use shared constants, types, and helpers

### SRP (Single Responsibility Principle)
- Each function, class, component, or module should have one clear responsibility
- A function MUST do one thing (one file) and do it well
- **Components MUST only render HTML/JSX** - they have ONE responsibility: presentation
- **Business logic belongs in hooks or utility functions** - NOT in components
- If a function does multiple things, split it into smaller functions
- If a component contains logic, extract it to hooks or utility functions

### Open-Closed Principle
- Code should be open for extension but closed for modification
- Design functions and classes to be extensible without changing existing code
- Prefer composition over modification when adding new features

---

## File Organization

### Functions (`lib/[feature]/`)
- **One function per file** - file name matches function name
- Pure utility functions, API calls, data transformations
- Example: `lib/moment/formatMomentPrice.ts`, `lib/moment/getInProcessTimelineApi.ts`

### Hooks (`hooks/`)
- Custom React hooks for state management, side effects, data fetching
- One hook per file - file name matches hook name
- Example: `hooks/useMoment.ts`, `hooks/usePreviewFileUrl.ts`

### Components (`components/`)
- **Components MUST contain ONLY HTML/JSX code** (< 120 lines)
- **ZERO business logic** - ALL logic goes to hooks or utility functions
- **NO calculations, conditionals, or transformations** in components
- **NO event handlers with logic** - extract to hooks
- Extract business logic to hooks or utility functions
- **Folder naming:**
  - Page-specific: `CreatePage/`, `ManagePage/` (PascalCase with "Page" suffix)
  - Layout/reusable: `Layout/`, `ui/` (no "Page" suffix)
  - Component names inside Page folders should NOT include page prefix
    - ‚úÖ GOOD: `ManagePage/Tabs.tsx`, `ManagePage/Stats.tsx`
    - ‚ùå BAD: `ManagePage/ManageTabs.tsx`

### Providers (`lib/providers/`)
- All React providers in `lib/providers/` folder
- Each provider in its own file
- Client components (use "use client" directive)

### Supabase Queries (`supabase/[table_name]/`)
- Pure Supabase query functions organized by table
- Example: `supabase/in_process_tokens/selectTokens.ts`

### Types (`types/`)
- **ALL types, interfaces, and type definitions MUST be in `types/` folder**
- **NO exceptions** - types are NEVER defined in `lib/`, `components/`, `hooks/`, or anywhere else
- **If you find a type outside `types/`, move it immediately**
- Keep type definitions organized and easily discoverable
- File naming: `types/[feature].ts` (e.g., `types/collections.ts`, `types/moment.ts`)
- Example: `types/collections.ts` exports `CollectionsResponse` interface

### Mock Data (`lib/mocks/[feature]/`)
- All mock variables in `lib/mocks/[feature]/` folder
- Pure data exports (no logic)
- Example: `lib/mocks/moments/mockMoments.ts`

---

## Code Patterns

### Component Structure Pattern
**Rule**: Components = JSX/HTML only. Logic goes to hooks/functions.

```typescript
// ‚ùå BAD: Component with business logic - calculations
function MomentCard({ moment }) {
  const formattedPrice = new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD'
  }).format(moment.price);
  return <div>{formattedPrice}</div>;
}

// ‚ùå BAD: Component with business logic - derived state
const Media = () => {
  const { previewFile, imageFile, animationFile } = useMomentFormProvider();
  const hasSelectedFiles = Boolean(previewFile || imageFile || animationFile); // ‚ùå Logic in component
  return <div>{hasSelectedFiles ? <Upload /> : <Preview />}</div>;
};

// ‚ùå BAD: Component with business logic - event handlers
const Media = () => {
  const handleReset = () => {
    const currentName = metadata?.name || ""; // ‚ùå Logic in component
    resetForm();
    if (currentName) {
      setName(currentName); // ‚ùå Logic in component
    }
  };
  return <button onClick={handleReset}>Reset</button>;
};

// ‚úÖ GOOD: Component with extracted logic
// lib/moment/formatMomentPrice.ts
export const formatMomentPrice = (price: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD'
  }).format(price);
};

// hooks/useHasSelectedFiles.ts
export const useHasSelectedFiles = (
  previewFile: File | null,
  imageFile: File | null,
  animationFile: File | null
): boolean => {
  return Boolean(previewFile || imageFile || animationFile);
};

// hooks/useMediaReset.ts
export const useMediaReset = () => {
  const { metadata, resetForm, setName, setDescription } = useMomentFormProvider();
  
  const handleReset = () => {
    const currentName = metadata?.name || "";
    const currentDescription = metadata?.description || "";
    resetForm();
    if (currentName) setName(currentName);
    if (currentDescription) setDescription(currentDescription);
  };
  
  return { handleReset };
};

// components/MomentCard.tsx
import { formatMomentPrice } from '@/lib/moment/formatMomentPrice';
function MomentCard({ moment }) {
  return <div>{formatMomentPrice(moment.price)}</div>;
}

// components/Media.tsx
const Media = () => {
  const { previewFile, imageFile, animationFile } = useMomentFormProvider();
  const hasSelectedFiles = useHasSelectedFiles(previewFile, imageFile, animationFile);
  const { handleReset } = useMediaReset();
  return <div>{hasSelectedFiles ? <Upload /> : <Preview />}</div>;
};
```

### Extract useEffect Pattern
**Rule**: Always extract `useEffect` hooks from components into custom hooks.

```typescript
// ‚ùå BAD: useEffect in component
const Preview = () => {
  const [url, setUrl] = useState("");
  useEffect(() => {
    if (file) {
      const blobUrl = URL.createObjectURL(file);
      setUrl(blobUrl);
      return () => URL.revokeObjectURL(blobUrl);
    }
  }, [file]);
  return <img src={url} />;
};

// ‚úÖ GOOD: useEffect extracted to hook
// hooks/usePreviewFileUrl.ts
export const usePreviewFileUrl = (file: File | null): string => {
  const [url, setUrl] = useState("");
  useEffect(() => {
    if (file) {
      const blobUrl = URL.createObjectURL(file);
      setUrl(blobUrl);
      return () => URL.revokeObjectURL(blobUrl);
    }
  }, [file]);
  return url;
};

// components/Preview.tsx
const Preview = () => {
  const url = usePreviewFileUrl(file);
  return <img src={url} />;
};
```

### API Fetching Pattern
**Rule**: Use TanStack Query + separate API logic in `lib/`.

```typescript
// lib/moment/getInProcessTimelineApi.ts
export const getInProcessTimelineApi = async (): Promise<TimelineMoment[]> => {
  const res = await fetch("/api/timeline/inprocess");
  // ... error handling
  return data.moments || [];
};

// hooks/useInProcessTimeline.ts
import { useQuery } from "@tanstack/react-query";
import { getInProcessTimelineApi } from "@/lib/moment/getInProcessTimelineApi";

const useInProcessTimeline = () => {
  const query = useQuery({
    queryKey: ["in-process-timeline"],
    queryFn: getInProcessTimelineApi,
    staleTime: 60_000,
  });
  return {
    moments: query.data ?? [],
    isLoading: query.isLoading,
    error: query.error instanceof Error ? query.error : null,
  };
};
```

### File Selection Pattern
**Rule**: File selection and upload are separate. Selection stores blobs, upload happens later.

```typescript
// ‚úÖ GOOD: Selection separate from upload
// lib/fileSelect/handleImageSelection.ts
export const handleImageSelection = async (
  file: File,
  handlers: ImageSelectionHandlers
): Promise<void> => {
  // Store blob data - no upload happens here
  handlers.setImageFile(file);
  handlers.setPreviewFile(file);
};

// hooks/useFileSelect.ts
// Hook for file selection only - stores files as blobs.
// Upload logic is handled in useMomentMetadata.generateMetadataUri()
const useFileSelect = () => {
  const selectFile = async (event: any) => {
    const file = event.target.files[0];
    await handleImageSelection(file, handlers);
  };
  return { selectFile };
};

// hooks/useMomentMetadata.tsx
const useMomentMetadata = () => {
  const generateMetadataUri = async () => {
    // Upload happens here, when needed (e.g., on form submission)
    const result = await uploadFilesToArweave({ imageFile, previewFile });
  };
  return { generateMetadataUri };
};
```

### Type Organization Pattern
**Rule**: ALL types must be in `types/` folder. Functions/hooks/components import types, never define them.

```typescript
// ‚ùå BAD: Type defined in lib file
// lib/collections/fetchCollections.ts
export interface CollectionsResponse {
  status: "success" | "error";
  collections: Array<{ /* ... */ }>;
}

export async function fetchCollections(): Promise<CollectionsResponse> {
  // ...
}

// ‚ùå BAD: Type defined in component
// components/CreateForm/Collections.tsx
import { CollectionsResponse } from "@/lib/collections/fetchCollections";
type CollectionItem = CollectionsResponse["collections"][number]; // ‚ùå Local type definition

// ‚úÖ GOOD: Type in types folder
// types/collections.ts
export interface CollectionsResponse {
  status: "success" | "error";
  collections: Array<{
    id: number;
    address: string;
    chain_id: number;
    uri: string;
    name: string;
    created_at: string;
    default_admin: {
      username: string | null;
      address: string;
    };
  }>;
  pagination: {
    page: number;
    limit: number;
    total_pages: number;
  };
  message?: string;
}

// ‚úÖ GOOD: Function imports type
// lib/collections/fetchCollections.ts
import { CollectionsResponse } from "@/types/collections";

export async function fetchCollections(): Promise<CollectionsResponse> {
  // ...
}

// ‚úÖ GOOD: Component imports type
// components/CreateForm/Collections.tsx
import { CollectionsResponse } from "@/types/collections";

type CollectionItem = CollectionsResponse["collections"][number]; // ‚úÖ Using imported type
```

**When you encounter a type outside `types/`:**
1. **STOP** - Do not proceed until the type is moved
2. Create/update file in `types/` folder
3. Move the type definition there
4. Update original file to import the type
5. Update ALL files that reference the type

---

### Blob URL Management Pattern
**Rule**: Manage blob URLs separately from file storage with proper cleanup.

**Pattern for each file type:**
1. Create object URL when file exists
2. Add URL to blobUrls state
3. Revoke previous URL in cleanup (when file changes or component unmounts)

```typescript
// hooks/useBlobUrls.ts
interface UseBlobUrlsParams {
  previewFile: File | null;
  imageFile: File | null;
  animationFile: File | null;
}

export const useBlobUrls = ({
  previewFile,
  imageFile,
  animationFile,
}: UseBlobUrlsParams) => {
  const [blobUrls, setBlobUrls] = useState<BlobUrls>({});
  
  // Pattern: Create URL for previewFile
  useEffect(() => {
    if (previewFile) {
      const blobUrl = URL.createObjectURL(previewFile);
      setBlobUrls((prev) => ({ ...prev, preview: blobUrl }));
      return () => URL.revokeObjectURL(blobUrl);
    } else {
      // Cleanup when file is removed
      setBlobUrls((prev) => {
        if (prev.preview) URL.revokeObjectURL(prev.preview);
        const { preview: _preview, ...rest } = prev;
        return rest;
      });
    }
  }, [previewFile]);
  
  // Pattern: Create URL for animationFile (same pattern as previewFile)
  useEffect(() => {
    if (animationFile) {
      const blobUrl = URL.createObjectURL(animationFile);
      setBlobUrls((prev) => ({ ...prev, animation: blobUrl }));
      return () => URL.revokeObjectURL(blobUrl);
    } else {
      // Cleanup when file is removed
      setBlobUrls((prev) => {
        if (prev.animation) URL.revokeObjectURL(prev.animation);
        const { animation: _animation, ...rest } = prev;
        return rest;
      });
    }
  }, [animationFile]);
  
  // Pattern: Create URL for imageFile (same pattern as above)
  useEffect(() => {
    if (imageFile) {
      const blobUrl = URL.createObjectURL(imageFile);
      setBlobUrls((prev) => ({ ...prev, image: blobUrl }));
      return () => URL.revokeObjectURL(blobUrl);
    } else {
      // Cleanup when file is removed
      setBlobUrls((prev) => {
        if (prev.image) URL.revokeObjectURL(prev.image);
        const { image: _image, ...rest } = prev;
        return rest;
      });
    }
  }, [imageFile]);
  
  return {
    blobUrls,
    previewFileUrl: blobUrls.preview || "",
    animationFileUrl: blobUrls.animation || "",
    imageFileUrl: blobUrls.image || "",
  };
};
```

---

## Best Practices

### Function Design
- Keep functions small and focused
- Use descriptive names that clearly indicate purpose
- Prefer pure functions when possible (no side effects)
- Handle errors explicitly and gracefully

### Type Safety
- Use TypeScript types and interfaces consistently
- Avoid `any` types; use `unknown` when type is truly unknown
- **CRITICAL: ALL types MUST be defined in the `types/` folder**
- **NEVER define types in `lib/`, `components/`, `hooks/`, or any other folder**
- **If you see a type outside `types/`, move it immediately**
- Import types from `types/` folder in all files that need them

### Code Structure
- Group related functionality together
- Maintain clear separation of concerns
- Use consistent naming conventions
- Follow the existing project structure patterns
