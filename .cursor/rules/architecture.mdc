---
alwaysApply: true
---

# TypeScript Coding Principles

## üìã IMPORTANT: ALWAYS CHECK AND UPDATE THIS FILE

**BEFORE STARTING ANY TASK:**
1. **READ THIS FILE FIRST** - These rules apply to ALL project development
2. **UPDATE THIS FILE** - When the user provides guidance, patterns, or corrections, immediately update this file to reflect them
3. **REFERENCE THIS FILE** - Use these principles for every code change, file creation, or refactoring
4. **MAINTAIN CONSISTENCY** - All code must follow the patterns and rules defined here

**WHEN USER PROVIDES GUIDANCE:**
- If they correct a pattern or approach ‚Üí Update the relevant section in this file
- If they introduce a new pattern ‚Üí Add it to the Code Patterns section
- If they clarify a rule ‚Üí Update the rule to be more explicit
- If they change file organization ‚Üí Update the File Organization section

**This file is the single source of truth for all coding standards in this project.**

---

## ‚ö†Ô∏è CRITICAL RULE: ONE FUNCTION PER FILE ‚ö†Ô∏è

**THIS IS THE MOST IMPORTANT RULE - CHECK THIS FIRST BEFORE CREATING OR MODIFYING ANY FILE**

- **EVERY function MUST be in its own separate file**
- **The file name MUST match the function name** (e.g., `getMaxBlockTimestamp.ts` exports `getMaxBlockTimestamp`)
- **NO exceptions** - helper functions, type guards, utility functions, ALL functions must be separate files
- **If a file has multiple functions, you MUST split them immediately**

**Examples:**
- ‚úÖ GOOD: `lib/fileSelect/loadPdfJs.ts` exports only `loadPdfJs`
- ‚úÖ GOOD: `lib/fileSelect/isPdfJsLib.ts` exports only `isPdfJsLib`
- ‚ùå BAD: `lib/fileSelect/loadPdfJs.ts` contains both `loadPdfJs` AND `isPdfJsLib`
- ‚ùå BAD: `lib/utils/helpers.ts` with multiple functions - split into separate files

**Before creating or editing any file, ask yourself:**
1. Does this file contain only ONE exported function?
2. If there are helper functions, are they in separate files?
3. If there are type guards, are they in separate files?

**If the answer to any question is NO, split the file immediately.**

---

## Core Principles

### KISS (Keep It Simple, Stupid)
- Write simple, straightforward code that is easy to understand
- Avoid unnecessary complexity and over-engineering
- Prefer clear, readable solutions over clever ones

### DRY (Don't Repeat Yourself)
- Avoid code duplication
- Extract common logic into reusable functions or utilities
- Use shared constants, types, and helpers

### SRP (Single Responsibility Principle)
- Each function, class, or module should have one clear responsibility
- A function MUST do one thing (one file) and do it well
- If a function does multiple things, split it into smaller functions

### Open-Closed Principle
- Code should be open for extension but closed for modification
- Design functions and classes to be extensible without changing existing code
- Prefer composition over modification when adding new features

---

## File Organization

### Functions (`lib/[feature]/`)
- **One function per file** - file name matches function name
- Pure utility functions, API calls, data transformations
- Example: `lib/moment/formatMomentPrice.ts`, `lib/moment/getInProcessTimelineApi.ts`

### Hooks (`hooks/`)
- Custom React hooks for state management, side effects, data fetching
- One hook per file - file name matches hook name
- Example: `hooks/useMoment.ts`, `hooks/usePreviewFileUrl.ts`

### Components (`components/`)
- **Components should maintain HTML/JSX code only** (< 120 lines)
- Extract business logic to hooks or utility functions
- **Folder naming:**
  - Page-specific: `CreatePage/`, `ManagePage/` (PascalCase with "Page" suffix)
  - Layout/reusable: `Layout/`, `ui/` (no "Page" suffix)
  - Component names inside Page folders should NOT include page prefix
    - ‚úÖ GOOD: `ManagePage/Tabs.tsx`, `ManagePage/Stats.tsx`
    - ‚ùå BAD: `ManagePage/ManageTabs.tsx`

### Providers (`lib/providers/`)
- All React providers in `lib/providers/` folder
- Each provider in its own file
- Client components (use "use client" directive)

### Supabase Queries (`supabase/[table_name]/`)
- Pure Supabase query functions organized by table
- Example: `supabase/in_process_tokens/selectTokens.ts`

### Types (`types/`)
- All types defined in `types` folder
- Keep type definitions organized and easily discoverable

### Mock Data (`lib/mocks/[feature]/`)
- All mock variables in `lib/mocks/[feature]/` folder
- Pure data exports (no logic)
- Example: `lib/mocks/moments/mockMoments.ts`

---

## Code Patterns

### Component Structure Pattern
**Rule**: Components = JSX/HTML only. Logic goes to hooks/functions.

```typescript
// ‚ùå BAD: Component with business logic
function MomentCard({ moment }) {
  const formattedPrice = new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD'
  }).format(moment.price);
  return <div>{formattedPrice}</div>;
}

// ‚úÖ GOOD: Component with extracted logic
// lib/moment/formatMomentPrice.ts
export const formatMomentPrice = (price: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD'
  }).format(price);
};

// components/MomentCard.tsx
import { formatMomentPrice } from '@/lib/moment/formatMomentPrice';
function MomentCard({ moment }) {
  return <div>{formatMomentPrice(moment.price)}</div>;
}
```

### Extract useEffect Pattern
**Rule**: Always extract `useEffect` hooks from components into custom hooks.

```typescript
// ‚ùå BAD: useEffect in component
const Preview = () => {
  const [url, setUrl] = useState("");
  useEffect(() => {
    if (file) {
      const blobUrl = URL.createObjectURL(file);
      setUrl(blobUrl);
      return () => URL.revokeObjectURL(blobUrl);
    }
  }, [file]);
  return <img src={url} />;
};

// ‚úÖ GOOD: useEffect extracted to hook
// hooks/usePreviewFileUrl.ts
export const usePreviewFileUrl = (file: File | null): string => {
  const [url, setUrl] = useState("");
  useEffect(() => {
    if (file) {
      const blobUrl = URL.createObjectURL(file);
      setUrl(blobUrl);
      return () => URL.revokeObjectURL(blobUrl);
    }
  }, [file]);
  return url;
};

// components/Preview.tsx
const Preview = () => {
  const url = usePreviewFileUrl(file);
  return <img src={url} />;
};
```

### API Fetching Pattern
**Rule**: Use TanStack Query + separate API logic in `lib/`.

```typescript
// lib/moment/getInProcessTimelineApi.ts
export const getInProcessTimelineApi = async (): Promise<TimelineMoment[]> => {
  const res = await fetch("/api/timeline/inprocess");
  // ... error handling
  return data.moments || [];
};

// hooks/useInProcessTimeline.ts
import { useQuery } from "@tanstack/react-query";
import { getInProcessTimelineApi } from "@/lib/moment/getInProcessTimelineApi";

const useInProcessTimeline = () => {
  const query = useQuery({
    queryKey: ["in-process-timeline"],
    queryFn: getInProcessTimelineApi,
    staleTime: 60_000,
  });
  return {
    moments: query.data ?? [],
    isLoading: query.isLoading,
    error: query.error instanceof Error ? query.error : null,
  };
};
```

### File Selection Pattern
**Rule**: File selection and upload are separate. Selection stores blobs, upload happens later.

```typescript
// ‚úÖ GOOD: Selection separate from upload
// lib/fileSelect/handleImageSelection.ts
export const handleImageSelection = async (
  file: File,
  handlers: ImageSelectionHandlers
): Promise<void> => {
  // Store blob data - no upload happens here
  handlers.setImageFile(file);
  handlers.setPreviewFile(file);
};

// hooks/useFileSelect.ts
// Hook for file selection only - stores files as blobs.
// Upload logic is handled in useMomentMetadata.generateMetadataUri()
const useFileSelect = () => {
  const selectFile = async (event: any) => {
    const file = event.target.files[0];
    await handleImageSelection(file, handlers);
  };
  return { selectFile };
};

// hooks/useMomentMetadata.tsx
const useMomentMetadata = () => {
  const generateMetadataUri = async () => {
    // Upload happens here, when needed (e.g., on form submission)
    const result = await uploadFilesToArweave({ imageFile, previewFile });
  };
  return { generateMetadataUri };
};
```

### Blob URL Management Pattern
**Rule**: Manage blob URLs separately from file storage with proper cleanup.

```typescript
// hooks/useBlobUrls.ts
export const useBlobUrls = ({ previewFile, imageFile }: Params) => {
  const [blobUrls, setBlobUrls] = useState<BlobUrls>({});
  
  useEffect(() => {
    if (previewFile) {
      const blobUrl = URL.createObjectURL(previewFile);
      setBlobUrls((prev) => ({ ...prev, preview: blobUrl }));
      return () => URL.revokeObjectURL(blobUrl);
    }
  }, [previewFile]);
  
  return { previewFileUrl: blobUrls.preview || "" };
};
```

---

## Best Practices

### Function Design
- Keep functions small and focused
- Use descriptive names that clearly indicate purpose
- Prefer pure functions when possible (no side effects)
- Handle errors explicitly and gracefully

### Type Safety
- Use TypeScript types and interfaces consistently
- Avoid `any` types; use `unknown` when type is truly unknown
- Define types in the `types` folder

### Code Structure
- Group related functionality together
- Maintain clear separation of concerns
- Use consistent naming conventions
- Follow the existing project structure patterns
