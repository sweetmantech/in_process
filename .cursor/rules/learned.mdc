---
description: Architecture patterns, learnings, and reusable knowledge for the project
alwaysApply: true
---

# Architecture & Learnings

**Purpose**: This file contains all reusable learnings, patterns, and architectural decisions discovered during development. Use this as a reference when working on the project.

**When to Update**: 
- When you discover a reusable pattern or solution
- When you fix a mistake or receive a correction
- When you learn something about the project structure, libraries, or conventions
- When you establish a new architectural pattern

---

# User Specified Lessons

- You have an env in ./.env Use it.
- Read the file before you try to edit it.
- Keep all files under 100 lines of code to maintain readability and follow single responsibility principle
- **CRITICAL**: Always reference and follow `typescript.coding.principle.mdc` when writing ANY code
  - Follow KISS, DRY, SRP, Open-Closed principles
  - One function per file (file name matches function name)
  - Types go in `types/` folder
  - Supabase queries in `supabase/[table_name]/` folders
  - Keep functions small, focused, and pure when possible

---

# Database Schema Migration - Legacy vs Current Tables

**CRITICAL**: The following tables are **LEGACY** and will be removed in the future:
- `in_process_tokens` ❌ LEGACY
- `in_process_token_admins` ❌ LEGACY  
- `in_process_token_fee_recipients` ❌ LEGACY

**Current/Future Tables** (use these instead):
- `in_process_collections` ✅ - Collections (address, chain_id, default_admin, payout_recipient, uri)
- `in_process_moments` ✅ - Moments within collections (collection FK, token_id, uri, max_supply, created_at, updated_at)
- `in_process_admins` ✅ - Admins for collections/moments (collection FK, token_id, artist_address, hidden, granted_at)
- `in_process_moment_fee_recipients` ✅ - Fee recipients for moments (moment FK, artist_address, percent_allocation)
- `in_process_sales` ✅ - Sales for moments (moment FK, sale_start, sale_end, price_per_token, currency, funds_recipient)

**Key Relationships:**
- `in_process_moments.collection` → `in_process_collections.id`
- `in_process_admins.collection` → `in_process_collections.id` (also has token_id to identify specific moment)
- `in_process_moment_fee_recipients.moment` → `in_process_moments.id`
- `in_process_sales.moment` → `in_process_moments.id`

**When building queries:**
- Always use `in_process_moments` instead of `in_process_tokens`
- Always use `in_process_admins` instead of `in_process_token_admins`
- Join `in_process_collections` to get collection address and default_admin
- Join `in_process_admins` filtered by collection + token_id to get admins for a specific moment

---

# Cursor Learned Patterns

## SRP: Extract Supabase Queries from API Routes
**Pattern**: When you see inline Supabase queries in API route handlers, extract them into separate functions following SRP.

**Structure**:
- **Location**: `lib/supabase/[table_name]/[functionName].ts`
- **Function**: Pure query function that takes parameters and returns `{ data, error, count? }`
- **Route Handler**: Imports and calls the extracted function

**Example Refactoring**:
```typescript
// BEFORE (in route.ts):
const { data, error, count } = await supabase
  .from("in_process_moments")
  .select("...")
  .eq("collection.chain_id", chainId)
  .order("created_at", { ascending: false })
  .range(offset, offset + limit - 1);

// AFTER:
// lib/supabase/in_process_moments/selectMoments.ts
export async function selectMoments({
  chainId,
  offset,
  limit,
}: {
  chainId: number;
  offset: number;
  limit: number;
}) {
  const { data, error, count } = await supabase
    .from("in_process_moments")
    .select("...")
    .eq("collection.chain_id", chainId)
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);
  return { data, error, count };
}

// route.ts
import { selectMoments } from "@/lib/supabase/in_process_moments/selectMoments";
const { data, error, count } = await selectMoments({ chainId, offset, limit });
```

**Benefits**:
- **SRP**: Route handler focuses on HTTP logic, query function handles database logic
- **Reusability**: Query functions can be used across multiple routes/hooks
- **Testability**: Pure query functions are easier to test independently
- **Maintainability**: Database query logic is centralized and easier to update
- **Consistency**: Follows project pattern of one function per file in `supabase/[table_name]/` folders

**When to Apply**:
- Any inline Supabase query in API routes (`app/api/**/route.ts`)
- Any complex query that could be reused elsewhere
- When route handlers exceed ~100 lines (extract queries to reduce complexity)

## Make Query Functions Generic with Optional Parameters
**Pattern**: When extracting Supabase queries, make parameters optional to maximize reusability across different contexts.

**Structure**:
- **Optional Parameters**: Use `?` to make parameters optional (e.g., `chainId?: number`)
- **Default Empty Object**: Use `= {}` as default parameter to allow calling without arguments
- **Conditional Query Building**: Build query conditionally, only applying filters when parameters are provided

**Example Refactoring**:
```typescript
// BEFORE (required parameters):
export async function selectMoments({
  chainId,
  offset,
  limit,
}: {
  chainId: number;
  offset: number;
  limit: number;
}) {
  const { data, error, count } = await supabase
    .from("in_process_moments")
    .select("...")
    .eq("collection.chain_id", chainId)
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);
  return { data, error, count };
}

// AFTER (optional parameters):
export async function selectMoments({
  chainId,
  offset,
  limit,
}: {
  chainId?: number;
  offset?: number;
  limit?: number;
} = {}) {
  let query = supabase
    .from("in_process_moments")
    .select("...", { count: "exact" });

  if (chainId !== undefined) {
    query = query.eq("collection.chain_id", chainId);
  }

  query = query.order("created_at", { ascending: false });

  if (offset !== undefined && limit !== undefined) {
    query = query.range(offset, offset + limit - 1);
  }

  const { data, error, count } = await query;
  return { data, error, count };
}

// Usage examples:
await selectMoments(); // Get all moments
await selectMoments({ chainId: 1 }); // Filter by chainId only
await selectMoments({ chainId: 1, offset: 0, limit: 10 }); // Full filtering + pagination
```

**Benefits**:
- **Flexibility**: Same function can be used for different query scenarios
- **Reusability**: One function serves multiple use cases (list all, filter by chain, paginated, etc.)
- **Backward Compatible**: Existing calls still work, new calls can omit parameters
- **DRY**: Avoids creating multiple similar functions for slight variations

**When to Apply**:
- When query function might be used in different contexts with different filter needs
- When you want to avoid creating multiple similar functions (e.g., `selectAllMoments`, `selectMomentsByChain`, etc.)
- When parameters are naturally optional (e.g., pagination, filtering)

## Types Must Be Defined in `types/` Folder (Not `types/legacy/`)
**Pattern**: All TypeScript types/interfaces must be defined in the `types/` folder directly, NOT in `types/legacy/` subfolder.

**Structure**:
- **Location**: `types/[typeName].ts` (e.g., `types/inprocessTimeline.ts`)
- **Export**: Export interfaces/types from the types file
- **Import**: Import types from `@/types/[typeName]` in function files
- **Never use**: `types/legacy/` folder - it will be removed in the future

**Example**:
```typescript
// ✅ CORRECT:
// types/inprocessTimeline.ts
export interface InprocessTimelineMoment {
  address: string;
  token_id: string;
  // ...
}

// lib/timeline/getInprocessTimeline.ts
import type { InprocessTimelineMoment } from "@/types/inprocessTimeline";

// ❌ WRONG:
// lib/timeline/getInprocessTimeline.ts
export interface InprocessTimelineMoment { ... } // Types should not be in lib files

// ❌ WRONG:
import { Metadata } from "@/types/legacy/token"; // Don't use legacy folder
```

**Benefits**:
- **Consistency**: All types in one location (`types/` folder)
- **Future-proof**: Avoids dependency on legacy folder that will be removed
- **Discoverability**: Types are easy to find and organize
- **SRP**: Types separated from implementation logic

**When to Apply**:
- **Always**: When creating new types, put them in `types/` folder
- **Never**: Use `types/legacy/` folder for new types
- **Migration**: When updating code, move types from `types/legacy/` to `types/` if needed
